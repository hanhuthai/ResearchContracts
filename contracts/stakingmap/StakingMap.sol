/********************** @2022 Wizarre, All rights reserved *********************
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMmMMMMMMMMMMMMMNNMMMMNddNMMMMmmmmmNMMMMNddNMMMMNMMMMMMMMMMMMMMmMMMMMMMMM
MMMMMMMMdysNhoossydNMmosyyMM+ddd-NhssdNMMNdsshN-ddd+MMsysomMNdyssoohNysdMMMMMMMM
MMMMMMMMmss::NMMh/+o+/-ohhMMhhdm`:hNNmMMMMmMNy:.mdhhMNhho-/+o+/dMMN-:ssmMMMMMMMM
MMMMMMMMNoMhyhdNNNmsoyNh/:mMMMs.oNMhoNMMMMmodMNo.yMMMd:/hNyoymNNNdhyhNoNMMMMMMMM
MMMMMMMNy/:shhhhy/-syyhhy`.hho :hho-yhhhhhhy-shh: ohh.`yhhyyo./yhhhhs:/hNMMMMMMM
MMMMMMMd `+://sso:`.`---/:osoo.syhh+yyyssyyyohhyo-osso:/---`.`/oss//:o  mMMMMMMM
MMMMMMMd `s+s+:..``.-+yhmyddhhsmyoyosddyyddsoyoymsyhdhymhy+-.``..:+s+y  mMMMMMMM
MMMMMMMd  sm`  -shhy. sMNys+ho+ssymyoodmmhooydyos+oh+yyMMo -yhhs-  `ms  mMMMMMMM
MMMMMMMd `yds` `/ss+:/hddddhhodNNhdssyNMMNyssdhNNhshhddddh/:+ss/` `ydy  mMMMMMMM
MMMMMMMd  ooNh/-..`````     :sdhdssddshmmhsddsydhdo-     `````..-/dNoo  mMMMMMMM
MMMMMMMd `md+ymddysohs.   `odmmdoyNoNmohhoNNoNssdmmho`   .yhosyddmy+dm  mMMMMMMM
MMMMMMMd `Nmh+/oyo-+o` `  syMMsM/dy/NhdyhhhN:yd+MsMNyo  ` `o+-oyo:+hmm  mMMMMMMM
MMMMMMMd  -NNy+/+yy.  :../odyhohssohyhsooshshossh+hyd+/`-:  -yy+/+yNm.  mMMMMMMM
MMMMMMMd -/-::yNN/   +/`so/shhssyhyy+yy++hy+hshysyhho:oo`++   +Nms::-/. mMMMMMMM
MMMMMMMd oMy/MMh.   ss hMNNhs+:/++++/yhyyhy/++++::oshNhNy ys   .hMM:hM+ mMMMMMMM
MMMMMMMd hMooMo    ym`oMdhymhyo/    `ooo+oo`    .shhdmyhM+`ms    oM+oMy mMMMMMMM
MMMMMMMd mMsy-    yM:`Nmsdyhysys:  ` `:ys/` ` `hmMMdsshsom /My    :ysMm mMMMMMMM
MMMMMMMd.MMd.    yMh :yssMNhshymNy: /``Nm .: .yNdMN/hmMddM- dMs    .mMM`mMMMMMMM
MMMMMMMdoMh`    oMM- :omdoMMMMdhddm/ s.--.s /mhshMhydhhdoN/ :MM+    `dM+mMMMMMMM
MMMMMMMdmh`    :MMd  /yhhh+s:ysyy+hN+`d..d`+ddhyyssNNyddss+  mMM-    `ddmMMMMMMM
MMMMMMMMh`     dMMy  :hodoNoy+hysdmym-+dd/-mymhdhdyd+NNmyN-  hMMd     `hMMMMMMMM
MMMMMMMM.      .sNMh- /yddyms+NMm:mmhs`Nm yMmhdssyhs+dy+o: -dMNs`      .MMMMMMMM
MMMMMMMNd:       .sNNs.`sNNyhhoNMm+dh-`dd`:Moymhhdyhsdho`.sNNs.       /mMMMMMMMM
MMMMMMMdhmo:`      .odm+`:sddmmsmmo/o +--+ /dymddhhmms-`+md+`      `:sNymMMMMMMM
MMMMMMMd/sy:do-      `:hh/`:sdmdydm- ./  /``odmyhydo-./dy:`      -sh:yy:mMMMMMMM
MMMMMMMd`m/.+shh+-      .os/`:ohdds  - // - `hMNhs-./s+.     `-+hhs/./m mMMMMMMM
MMMMMMMd -.mho/-hNds:.    `-/-`.oo`    --    `oo-`-/-`   `./sdNy-/sdm`- mMMMMMMM
MMMMMMMd  oMoo/.mNyooss+/-`  ``       `/:`       ``  .-/+ssoohMm.+osMo  mMMMMMMM
MMMMMMMd  myssh+hN.`o++/oNmo+/-.`  `.+hddh/.`  `.-++smm+/++o`.Nhohssyd  mMMMMMMM
MMMMMMMd  ++++osys-..--:/++:/yso+/:/o+-``-+o/:/+oss::++/:--..:syso++++  mMMMMMMM
MMMMMMMMh/.`-+hdmoohdmmmmddhmmmy+ooh/ .ys` +hoo+ymmmhddmmmmdhoomdh+-`.+hMMMMMMMM
MMMMMMMMMNmhs.`::`yhymdyoshNdsddyy. .+mNNm+` -yydhsmNhsoymdyhs /:`.sdmNMMMMMMMMM
MMMMMMMMMsohh.ymhy+//+./NMNssh+::.`+dmymmymd/`.::+hosNMm/.+//+yhmy.dh+yMMMMMMMMM
MMMMMMMMMNhysmMMMMMMMMh+MNhNMMMNNMdysyNMMNssydMNNMMMNhNN+dMMMMMMMMmsydNMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
// https://bscscan.com/address/0xd60041d8497dd38242b77e3b05879cf38712c502#code
// stake 100k =1 điểm, cứ 1 điểm 1 ngày sẽ được 1 cái búa, 2 ngày 2 cái búa, nếu cái búa đạt đến cái mốc nhất định thì cho đổi quà
// SPDX-License-Identifier: None
pragma solidity ^0.8.15;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

abstract contract StakingMapV1Contract {
    struct Stake {
        uint32 createdAt;
        uint32 endAt;
        uint32 age;
        uint32 stakesAmount;
    }

    function getStakes(address _userAddress) external virtual view returns (Stake[] memory _stakes, uint256[] memory _indexes);

    function stakesCountForAddress(address _userAddress) external virtual view returns (uint256);

    function getActiveStakes(address _userAddress) external virtual view returns (Stake[] memory _stakes, uint256[] memory _indexes);
}

contract StakingMapV2 is Ownable, Pausable {
    using SafeERC20 for IERC20;

    IERC20 public TOKEN;
    StakingMapV1Contract public STAKING_MAP_V1;
    uint256 public TOKEN_SINGLE_STAKE_AMOUNT = 100000 * 10 ** 18; //100k
    bool public BLOCK_NEW_STAKES = false;
    uint32 public START_TIMESTAMP = 1647698400; //  19 March 2022 14:00:00 UTC (start 1st staking map)
    Map[] MAPS;
    Stake[] public STAKES;
    mapping(address => uint256[]) public stakesOf;
    mapping(uint256 => address) public ownerOf;

    struct Map {
        uint32 period; // absolute period from START_TIMESTAMP
        uint32 completionBonusPercent;
    }

    struct Stake {
        uint32 createdAt;
        uint32 endAt;
        uint32 age;
        uint32 stakesAmount;
    }

    struct StakeOutput {
        uint32 createdAt;
        uint32 endAt;
        uint32 age;
        uint32 stakesAmount;
        uint32 startPos; // starting position period
        uint32 currentPos; // current position on map, starting from 0 on 1st map period
        uint32[] bonusPeriods;
        uint32[] bonusPercents;
        uint8 mapVersion;
    }

    event Staked(uint256 stakeId, address userAddress, uint256 stakesAmount);
    event ReducedStake(uint256 stakeId, address userAddress, uint32 beforeAmount, uint256 reduceBy);

    constructor(
        IERC20 _token,
        StakingMapV1Contract _stakingMapV1
    ) {
        TOKEN = _token;
        STAKING_MAP_V1 = _stakingMapV1;

        // 1st map bonus - 120days, 25%
        uint32[] memory _period = new uint32[](1);
        uint32[] memory _bonus = new uint32[](1);
        _period[0] = 10368000;
        _bonus[0] = 25;
        setMaps(_period, _bonus);
    }

    function setStartTimestamp(uint32 _startTimestamp) external onlyOwner {
        START_TIMESTAMP = _startTimestamp;
    }

    function setStakingMapV1(StakingMapV1Contract _stakingMapV1) external onlyOwner {
        STAKING_MAP_V1 = _stakingMapV1;
    }

    function setMaps(uint32[] memory _period, uint32[] memory _completionBonusPercent) public onlyOwner {
        require(_period.length == _completionBonusPercent.length, "Both parameters length must be the same");

        delete MAPS;
        for (uint256 i = 0; i < _period.length; i++) {
            MAPS.push(
                Map({
                    period: _period[i],
                    completionBonusPercent: _completionBonusPercent[i]
                }));
        }
    }

    function setBlockNewStakes(bool _blockNewStakes) external onlyOwner {
        BLOCK_NEW_STAKES = _blockNewStakes;
    }

    function getMaps() external view returns (Map[] memory){
        return MAPS;
    }

    function timestampOfNewMap() external view returns (uint32){
        uint32 curPeriod = uint32(block.timestamp) - START_TIMESTAMP;
        for (uint256 i = 0; i < MAPS.length; i++) {
            if (curPeriod < MAPS[i].period) {
                return START_TIMESTAMP + MAPS[i].period;
            }
        }

        return 0;
    }

    function getLocalStake(address _userAddress, uint256 _index) external view returns (Stake memory _stake, uint256 _id){
        _stake = STAKES[stakesOf[_userAddress][_index]];
        _id = stakesOf[_userAddress][_index];
    }

    function getLocalStakes(address _userAddress) external view returns (Stake[] memory _stakes, uint256[] memory _indexes){
        uint256[] memory _stakeIds = stakesOf[_userAddress];
        _stakes = new Stake[](_stakeIds.length);
        _indexes = _stakeIds;
        for (uint256 i = 0; i < _stakeIds.length; i++) {
            _stakes[i] = STAKES[_stakeIds[i]];
        }
    }

    function getStakes(address _userAddress) external view returns (StakeOutput[] memory _stakes, uint256[] memory _indexes){
        uint256[] memory _stakeIds = stakesOf[_userAddress];

        // Fetch stakes from V1 contract
        StakingMapV1Contract.Stake[] memory _stakesV1;
        uint256[] memory _indexesV1;
        (_stakesV1, _indexesV1) = STAKING_MAP_V1.getStakes(_userAddress);

        _stakes = new StakeOutput[](_stakesV1.length + _stakeIds.length);
        _indexes = new uint256[](_stakesV1.length + _stakeIds.length);

        for (uint256 i = 0; i < _stakesV1.length; i++) {
            _stakes[i] = _createStakeOutput(_stakeStructAdapter(_stakesV1[i]), 1);
            _indexes[i] = _indexesV1[i];
        }

        // Fetch stakes from this contract
        uint256 _stakesIterator = _stakesV1.length;
        for (uint256 i = 0; i < _stakeIds.length; i++) {
            _stakes[_stakesIterator] = _createStakeOutput(STAKES[_stakeIds[i]], 2);
            _indexes[_stakesIterator] = _stakeIds[i];
            _stakesIterator++;
        }
    }

    function calculateStartPos(uint32 _createdAt, uint32 _age) public view returns (uint32){
        uint32 _output = 0;
        for (uint256 i = 0; i < MAPS.length; i++) {

            // If stake creation day is higher than a new map, then use it
            if (_createdAt - START_TIMESTAMP - _age > MAPS[i].period) {
                if (MAPS[i].period > _output) {// in case data in MAPS are not in inc order
                    _output = MAPS[i].period;
                }
            }
        }

        return _output + _age;
    }

    function getLocalActiveStakes(address _userAddress) external view returns (Stake[] memory _stakes, uint256[] memory _indexes){
        uint256[] memory _stakeIds = stakesOf[_userAddress];

        uint256 activeStakesAmount = 0;
        for (uint256 i = 0; i < _stakeIds.length; i++) {
            if (0 == STAKES[_stakeIds[i]].endAt) {
                activeStakesAmount++;
            }
        }

        _stakes = new Stake[](activeStakesAmount);
        _indexes = new uint256[](activeStakesAmount);
        uint256 j = 0;
        for (uint256 i = 0; i < _stakeIds.length; i++) {
            if (0 == STAKES[_stakeIds[i]].endAt) {
                _stakes[j] = STAKES[_stakeIds[i]];
                _indexes[j] = _stakeIds[i];
                j++;
            }
        }
    }

    function getActiveStakes(address _userAddress) external view returns (StakeOutput[] memory _stakes, uint256[] memory _indexes){
        uint256[] memory _stakeIds = stakesOf[_userAddress];
        uint256 localActiveStakesAmount = 0;
        for (uint256 i = 0; i < _stakeIds.length; i++) {
            if (0 == STAKES[_stakeIds[i]].endAt) {
                localActiveStakesAmount++;
            }
        }

        // Fetch stakes from V1 contract
        StakingMapV1Contract.Stake[] memory _stakesV1;
        uint256[] memory _indexesV1;
        (_stakesV1, _indexesV1) = STAKING_MAP_V1.getActiveStakes(_userAddress);

        _stakes = new StakeOutput[](_stakesV1.length + localActiveStakesAmount);
        _indexes = new uint256[](_stakesV1.length + localActiveStakesAmount);

        for (uint256 i = 0; i < _stakesV1.length; i++) {
            _stakes[i] = _createStakeOutput(_stakeStructAdapter(_stakesV1[i]), 1);
            _indexes[i] = _indexesV1[i];
        }

        // Fetch stakes from this contract
        uint256 _stakesIterator = _stakesV1.length;
        for (uint256 i = 0; i < _stakeIds.length; i++) {
            if (0 == STAKES[_stakeIds[i]].endAt) {
                _stakes[_stakesIterator] = _createStakeOutput(STAKES[_stakeIds[i]], 2);
                _indexes[_stakesIterator] = _stakeIds[i];
                _stakesIterator++;
            }
        }
    }

//_stakesAmount is constant of 100k
    function stake(uint256 _stakesAmount) external whenNotPaused returns (uint256){
        require(false == BLOCK_NEW_STAKES, "NEW_STAKES_NOT_AVAILABLE");

        uint256 _totalTokenStakeAmount = _stakesAmount * TOKEN_SINGLE_STAKE_AMOUNT;
        TOKEN.safeTransferFrom(_msgSender(), address(this), _totalTokenStakeAmount);

        uint256 _stakesLen = STAKES.length;
        _createStakeEntry(_stakesLen, _stakesAmount, 0);

        emit Staked(_stakesLen, _msgSender(), _stakesAmount);

        return _stakesLen;
    }

    function _createStakeEntry(uint256 _stakesLen, uint256 _stakesAmount, uint32 _age) internal {
        stakesOf[_msgSender()].push(_stakesLen);
        ownerOf[_stakesLen] = _msgSender();
        STAKES.push(
            Stake({
                createdAt: uint32(block.timestamp),
                endAt: 0,
                age: uint32(_age),
                stakesAmount: uint32(_stakesAmount)
            })
        );
    }

    function reduceLocalStake(uint256 _stakeId, uint256 _amountToReduce) public whenNotPaused {
        require(_msgSender() == ownerOf[_stakeId], "NOT_OWNER");
        _reduceLocalStake(_stakeId, _amountToReduce);
    }

    function reduceAllLocalStakes() external onlyOwner() {
        for (uint256 i = 0; i < STAKES.length; i++) {
            if (STAKES[i].endAt == 0) {
                _reduceLocalStake(i, STAKES[i].stakesAmount);
            }
        }
    }

    function _reduceLocalStake(uint256 _stakeId, uint256 _amountToReduce) internal {
        address _stakeOwner = ownerOf[_stakeId];
        require(uint256(STAKES[_stakeId].stakesAmount) >= _amountToReduce, "CAN_NOT_REDUCE_MORE_THAN_AVAILABLE");
        require(uint256(STAKES[_stakeId].endAt) == 0, "STAKE_REDUCED_ALREADY");
        STAKES[_stakeId].endAt = uint32(block.timestamp);

        emit ReducedStake(_stakeId, _stakeOwner, STAKES[_stakeId].stakesAmount, _amountToReduce);

        uint256 _newStakeAmount = uint256(STAKES[_stakeId].stakesAmount) - _amountToReduce;
        if (_newStakeAmount > 0) {
            uint32 _age = STAKES[_stakeId].endAt - STAKES[_stakeId].createdAt + STAKES[_stakeId].age;
            _createStakeEntry(STAKES.length, _newStakeAmount, _age);
        }

        uint256 _totalTokenReturnAmount = _amountToReduce * TOKEN_SINGLE_STAKE_AMOUNT;
        TOKEN.safeTransfer(_stakeOwner, _totalTokenReturnAmount);
    }

    function stakesCount() external view returns (uint256) {
        return STAKES.length;
    }

    function localStakesCountForAddress(address _userAddress) public view returns (uint256){
        return stakesOf[_userAddress].length;
    }

    function stakesCountForAddress(address _userAddress) external view returns (uint256){
        return localStakesCountForAddress(_userAddress) + STAKING_MAP_V1.stakesCountForAddress(_userAddress);
    }

    function _stakeStructAdapter(StakingMapV1Contract.Stake memory _stake) internal pure returns (Stake memory){
        return
            Stake({
                createdAt : _stake.createdAt,
                endAt : _stake.endAt,
                age : _stake.age,
                stakesAmount : _stake.stakesAmount
            });
    }

    function _createStakeOutput(Stake memory _stake, uint8 _mapVersion) internal view returns (StakeOutput memory){
        uint32 _endOrNowTimestamp;
        if (_stake.endAt > 0) {
            _endOrNowTimestamp = _stake.endAt;
        } else {
            _endOrNowTimestamp = uint32(block.timestamp);
        }

        uint32 startPos = calculateStartPos(_stake.createdAt, _stake.age);

        return
            StakeOutput({
                createdAt: _stake.createdAt,
                endAt: _stake.endAt,
                age: _stake.age,
                stakesAmount: _stake.stakesAmount,
                startPos: startPos,
                currentPos: startPos + (_endOrNowTimestamp - _stake.createdAt),
                bonusPeriods: _mapPeriods(),
                bonusPercents: _calculateBonuses(_stake.createdAt, _stake.age, _stake.endAt),
                mapVersion: _mapVersion
            });
    }

    function _mapPeriods() internal view returns (uint32[] memory){
        uint32[] memory output = new uint32[](MAPS.length);
        for (uint256 i = 0; i < MAPS.length; i++) {
            output[i] = MAPS[i].period;
        }

        return output;
    }

    function _calculateBonuses(uint32 _createdAt, uint32 _age, uint32 _endAt) internal view returns (uint32[] memory){
        uint32[] memory output = new uint32[](MAPS.length);
        uint32 _stakeEndTime = _endAt;

        // End stake lub current time if not finished
        if (0 == _endAt) {
            _stakeEndTime = uint32(block.timestamp);
        }

        for (uint256 i = 0; i < MAPS.length; i++) {
            output[i] = 0;

            // If stake period length is longer than a single map
            if ((_stakeEndTime - _createdAt + _age) > MAPS[i].period) {
                // If stake was created before map ended
                if ((_createdAt - _age) < START_TIMESTAMP + MAPS[i].period) {
                    output[i] = MAPS[i].completionBonusPercent;
                }
            }
        }

        return output;
    }

    function returnAccidentallySent(IERC20 _tokenToSent) external onlyOwner {
        require(address(_tokenToSent) != address(TOKEN));
        uint256 _amount = _tokenToSent.balanceOf(address(this));
        _tokenToSent.safeTransfer(_msgSender(), _amount);
    }

    function tokenLockedAmount() public view returns (uint256){
        uint256 _usersTokenAmount = 0;
        uint256 _len = STAKES.length;
        for (uint256 i = 0; i < _len; i++) {
            if (0 == STAKES[i].endAt) {
                _usersTokenAmount += STAKES[i].stakesAmount * TOKEN_SINGLE_STAKE_AMOUNT;
            }
        }

        return _usersTokenAmount;
    }

    function returnRemainingTokens() external onlyOwner {
        uint256 _usersTokenAmount = tokenLockedAmount();
        uint256 _toReturnAmount = TOKEN.balanceOf(address(this)) - _usersTokenAmount;
        if (_toReturnAmount > 0) {
            TOKEN.safeTransfer(_msgSender(), _toReturnAmount);
        }
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}